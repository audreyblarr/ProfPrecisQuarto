<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ProfPrecisAudreyBlarr</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">ProfPrecisAudreyBlarr</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" rel="" target="" aria-current="page">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#software-engineering-at-google" id="toc-software-engineering-at-google" class="nav-link active" data-scroll-target="#software-engineering-at-google">Software Engineering at Google</a>
  <ul class="collapse">
  <li><a href="#preface" id="toc-preface" class="nav-link" data-scroll-target="#preface">Preface</a></li>
  <li><a href="#what-is-software-engineering" id="toc-what-is-software-engineering" class="nav-link" data-scroll-target="#what-is-software-engineering">What is Software Engineering?</a></li>
  <li><a href="#how-to-work-well-on-teams" id="toc-how-to-work-well-on-teams" class="nav-link" data-scroll-target="#how-to-work-well-on-teams">How to Work Well on Teams</a></li>
  <li><a href="#knowledge-sharing" id="toc-knowledge-sharing" class="nav-link" data-scroll-target="#knowledge-sharing">Knowledge Sharing</a></li>
  </ul></li>
  <li><a href="#fuzzingbook" id="toc-fuzzingbook" class="nav-link" data-scroll-target="#fuzzingbook">FuzzingBook</a>
  <ul class="collapse">
  <li><a href="#introduction-to-software-testing" id="toc-introduction-to-software-testing" class="nav-link" data-scroll-target="#introduction-to-software-testing">Introduction to Software Testing</a></li>
  <li><a href="#coverage" id="toc-coverage" class="nav-link" data-scroll-target="#coverage">Coverage</a></li>
  <li><a href="#fuzzing" id="toc-fuzzing" class="nav-link" data-scroll-target="#fuzzing">Fuzzing</a></li>
  <li><a href="#mutation-analysis" id="toc-mutation-analysis" class="nav-link" data-scroll-target="#mutation-analysis">Mutation Analysis</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ProfPrecisAudreyBlarr</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>My name is Audrey Blarr, and welcome to my Quarto-generated website! Here, I will be posting my Professional Precis for CMPSC-203 Software Engineering.</p>
<p>This site features summaries, reflections, and use-cases regarding chapters of three books: FuzzingBook, DebuggingBook, and Software Engineering at Google</p>
<p>To learn more about Quarto websites visit <a href="https://quarto.org/docs/websites" class="uri">https://quarto.org/docs/websites</a>.</p>
<section id="software-engineering-at-google" class="level1">
<h1>Software Engineering at Google</h1>
<section id="preface" class="level2">
<h2 class="anchored" data-anchor-id="preface">Preface</h2>
<section id="summary" class="level4">
<h4 class="anchored" data-anchor-id="summary">Summary</h4>
<p>The terms “software engineering” and “programming” have been used interchangeably over the years, although they have different implications. As software engineering isn’t currently as rigorous as other areas of engineering, more tedious methods of engineering will be necessary as software becomes more commonly integrated into our lives. Software engineering can be referred to as “programming integrated over time”, whereas we focus on not only writing the code itself, but the tools and processes needed to achieve and maintain sustainable code. Within these processes, three main topics are of importance: “time and change”, “scale and growth”, and “trade-offs and costs”.</p>
</section>
<section id="reflection" class="level4">
<h4 class="anchored" data-anchor-id="reflection">Reflection</h4>
</section>
<section id="use-cases" class="level4">
<h4 class="anchored" data-anchor-id="use-cases">Use Cases</h4>
</section>
</section>
<section id="what-is-software-engineering" class="level2">
<h2 class="anchored" data-anchor-id="what-is-software-engineering">What is Software Engineering?</h2>
<section id="summary-1" class="level4">
<h4 class="anchored" data-anchor-id="summary-1">Summary</h4>
<p>Software engineers must concern themselves with the need for change as time passes, unlike typical engineers. Furthermore, there exists issues of scale and efficiency, and outcomes with high stakes after making complex software decisions. Distinctions between “software engineering” and “programming” are very important, as the life span of given code allows for a prediction of its sustainability, or how much change will have to be implemented to the program’s dependencies. Capability is important when deciding whether or not to implement change. You also must consider the scale of the project, especially since software engineering is typically a team effort. Although team projects can pose new problems, there’s more potential in discovering viable solutions. Trade-offs must be evaluated often, as some implementations come with higher stakes than others. The level of broader change necessary to a program is dependent on both the amount of programmers working on a project, and their levels of skill in programming. Projects must also be adjusted to changing externalities, such as upgrades to programs, depending on the value and necessity of the given upgrade. Factors such as expertise, stability, conformity, familiarity, and policy can affect a codebase’s flexibility. Some costs involved within trade-offs include financial, resource, personnel, transaction, opportunity, and societal costs. It’s important to be evidence-driven rather than making assumptions when debating trade-offs and the risks associated within.</p>
</section>
<section id="reflection-1" class="level4">
<h4 class="anchored" data-anchor-id="reflection-1">Reflection</h4>
</section>
<section id="use-cases-1" class="level4">
<h4 class="anchored" data-anchor-id="use-cases-1">Use Cases</h4>
</section>
</section>
<section id="how-to-work-well-on-teams" class="level2">
<h2 class="anchored" data-anchor-id="how-to-work-well-on-teams">How to Work Well on Teams</h2>
<section id="summary-2" class="level4">
<h4 class="anchored" data-anchor-id="summary-2">Summary</h4>
<p>Cultural and social aspects of software engineering are crucial, as it’s a team endeavor. A huge issue in the software engineering world includes insecurity, as people are afraid of others viewing their unfinished work or criticizing their completed work. A phenomenon known as The Genius Myth is exhibited by many in the software engineering industry as we idolize individuals such as Linus Torvalds and attest them as the single-handed creators of large programs such as Linux. Although sparking the invention himself, Linus shared his implementations and discoveries with several others, allowing for collaboration and new perspectives on debugging. The program is now a hundred times larger than its original kernal, and is being worked on by thousands. The Genius Myth emerges because we strive to imitate these big-name creators rather than ulitizing the resources of collaboration in fear of being critcized for not being a ‘genius’. Hiding your code is super harmful, as you may not know if you’re on the right track. It’s easy to make fundamental mistakes early on, and collaborating allows you to increase the Bus Factor of your code. If you, the sole creator of a program, were to hypothetically get hit by a bus, there would be nothing stopping your project from failing to be implemented. Working with others is also much faster, and it’s much better to be a component of a successful program as opposed to the crucial part of a failed one. Working in a team allows for an instantaneous feedback loop so you know when to correct your plans or designs. The ‘three pillars’ of social skills and success include ‘humility’, ‘respect’, and ‘trust’, and creating relationships through these skills allow for richer relationships with coworkers and an increased ability to complete the project. Properly documenting any failures within a project can prevent history from repeating itself and boost the understandings of others.</p>
</section>
<section id="reflection-2" class="level4">
<h4 class="anchored" data-anchor-id="reflection-2">Reflection</h4>
</section>
<section id="use-cases-2" class="level4">
<h4 class="anchored" data-anchor-id="use-cases-2">Use Cases</h4>
</section>
</section>
<section id="knowledge-sharing" class="level2">
<h2 class="anchored" data-anchor-id="knowledge-sharing">Knowledge Sharing</h2>
<section id="summary-3" class="level4">
<h4 class="anchored" data-anchor-id="summary-3">Summary</h4>
<p>Many challenges can occur when a weak culture of learning exists, such as a lack of psychological safety (a fear of criticism or making mistakes) and information islands (lack of communication/shared resources), including information fragmentation, duplication, and skewing. Additionally, there are risks of single point of failure (related to the bus factor), all-or-nothing expertise (lack of middle-ground contributors), parroting (mindless copying), and haunted graveyards (avoiding areas of code out of fear). Software engineering is a multiperson process that relies on people and expertise. Personalized advice from experts is crucial, but it’s limited to small numbers. Tribal knowledge, which exists between the knowledge of individual team members and what is documented, is also valuable. Experts can synthesize their knowledge and assess the relevance of documentation for individual use cases. Communication and coordination are essential for effective learning; no single knowledge-sharing approach is the correct solution for all learning styles, and the best approach will depend on the organization’s growth. To learn efficiently you must first acknowledge your own lack of understanding, and welcome criticism rather than fear it. Mentorships can be extremely useful resources for novices who may lack either the understanding or confidence to efficiently contribute. Building this psychological safety beginning on a one-on-one scale can improve a novice’s fear of contributing to larger-scale group solutions, and creating a safe environment without adversial behaviors/reactions is crucial. Learning is an ongoing process, so it’s important to always ask questions or for further clarification when necessary, even if you consider yourself an expert. You also must ensure your understanding with pre-existing code and designs so you can properly decide if certain changes need to be implemented, rather than taking an easy route and rewriting the entire code. One-on-one help is limited in scale, so it’s beneficial to seek help from the greater community. Through mediums such as group chats and mailing lists, you can not only participate in community-based learning, but also document the questions and answers discussed for other newcomers to rely on. Teaching is not just limited to experts; through office hours, tech talks, classes, and documenting/reviewing code, google engineers are constantly teaching each other their areas of expertise. A culture that promotes open and honest knowledge sharing through common respect and recognition distributes that knowledge efficiently across the organization and allows that organization to scale over time.</p>
</section>
<section id="reflection-3" class="level4">
<h4 class="anchored" data-anchor-id="reflection-3">Reflection</h4>
</section>
<section id="use-cases-3" class="level4">
<h4 class="anchored" data-anchor-id="use-cases-3">Use Cases</h4>
</section>
</section>
</section>
<section id="fuzzingbook" class="level1">
<h1>FuzzingBook</h1>
<section id="introduction-to-software-testing" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-software-testing">Introduction to Software Testing</h2>
<section id="summary-4" class="level4">
<h4 class="anchored" data-anchor-id="summary-4">Summary</h4>
<p>It’s essential to create testing for your implemented software to ensure accuracy. Simple examples of software testing may include calculations like square-root testing, where you can incorporate Python control structures (while, if), assignments, and comparisons. You can incorporate ‘print’ statements into testing to observe closely how the function is being implemented. For instances like the square root example, you can test its accuracy by working backwards and multiplying the answer to itself. However, it’s more efficient to use automated testing, where you log the accurate answer and test the function to see if the output matches the desired answer. The ‘assert’ keyword can be used, which returns nothing if the function’s output matches and raises an error if not. You can use an ‘epsilon’ value to ensure your function’s output remains below a specified value, which gets rid of any rounding inaccuracies. These tests can be incorporated straight into the implementation as well to save space and time. However, you must be able to both formulate and afford these run-time checks. You can only test a finite amount of inputs, so there’s a limit to the testing in that regard.</p>
</section>
<section id="reflection-4" class="level4">
<h4 class="anchored" data-anchor-id="reflection-4">Reflection</h4>
</section>
<section id="use-cases-4" class="level4">
<h4 class="anchored" data-anchor-id="use-cases-4">Use Cases</h4>
</section>
</section>
<section id="coverage" class="level2">
<h2 class="anchored" data-anchor-id="coverage">Coverage</h2>
<section id="summary-5" class="level4">
<h4 class="anchored" data-anchor-id="summary-5">Summary</h4>
<p>The term “code coverage” refers to the ability to measure which parts of a program are being executed during a given test run, a process crucial for attempting to cover as much code as possible using a test generator. A simple Python command, ‘cgi_decode()’, will allow you to take an encoded string and decode it to its original form. You can derive tests using either Black-box testing, testing for specification, or White-box testing, testing for implementation. White-box testing covers the structural features of a code, such as statement coverage and branch coverage. Furthermore, this method of testing keeps track of which code was executed so a programmer can then focus on writing tests to cover the uncovered code. Dynamic analysis can take place using the command ‘sys.settrace()’to track how execution proceeds while decoding. Defining a ’Coverage’ object to not only keep track of which lines are executed, but the function names as well, which is helpful when a program spans over many files. Along with Python, most other coding languages have their own methods of testing code coverage. We must also set up a results checker to ensure that ‘cgi_decode()’ is error-free.</p>
</section>
<section id="reflection-5" class="level4">
<h4 class="anchored" data-anchor-id="reflection-5">Reflection</h4>
</section>
<section id="use-cases-5" class="level4">
<h4 class="anchored" data-anchor-id="use-cases-5">Use Cases</h4>
</section>
</section>
<section id="fuzzing" class="level2">
<h2 class="anchored" data-anchor-id="fuzzing">Fuzzing</h2>
<section id="summary-6" class="level4">
<h4 class="anchored" data-anchor-id="summary-6">Summary</h4>
<p>The input of a program can take many forms, including data prompted by user or read from a file. These inputs determine how a program behaves, including its failures, so it’s important to test each valid input, or a program’s ‘language’. Grammars are used to specify input languages formally, where a wide range of the properties of an input language is expressed, as well as the syntactical structure of an input. Consisting of a ‘start’ symbol followed by a set of expansion rules, grammers formally define the language in the sense that anything that can be derived from ‘start’ using the expansion rules is part of the language. Grammers can even be recursive and cover full arithmetic expressions. Using a format based on strings and lists is the simplest way to write grammars using Python. However, this method may be inefficient with its large number of search and replace operations, and it may not even produce a string. Grammars are not limited to just formal languages; they can be used to produce natural language as well. Grammar-generated inputs can be used as seeds in mutation-based fuzzing, where more complex constraints can be satisfied. Helper functions can be utilized in testing grammars, checking whether all used symbols are defined or not, and whether or not they’re reachable from the starting point.</p>
</section>
<section id="reflection-6" class="level4">
<h4 class="anchored" data-anchor-id="reflection-6">Reflection</h4>
</section>
<section id="use-cases-6" class="level4">
<h4 class="anchored" data-anchor-id="use-cases-6">Use Cases</h4>
</section>
</section>
<section id="mutation-analysis" class="level2">
<h2 class="anchored" data-anchor-id="mutation-analysis">Mutation Analysis</h2>
<section id="summary-7" class="level4">
<h4 class="anchored" data-anchor-id="summary-7">Summary</h4>
<p>Mutations, or artificial faults, can be injected into code to check whether or not a test suite will pick up on specific bugs. On subject programs there are two highlighted methods of running mutation analysis; MuFunctionAnalyzer (implementing mutation analysis for individual functions) and MuProgramAnalyzer (implementing mutation analysis for standalone programs containing test suites). Structural coverage, as discussed previously, may not be enough since an execution that produces a wrong output yet is unnoticed by the test suite is counted exactly the same as an execution that produces the right output. Ineffective tests may achieve 100% code coverage, yet inaccurately represent the severe lack of ability of the program to detect bugs. Seeding artificial faults, or mutations, into code and assessing the accuracy of the test suites helps to assess how the test suite would behave with real bugs. The set of valid tokens different from the original that make it past the compilation stage is considered to be its possible set of mutations that represent the probable faults in the program. The mutation score obtained represents the ability of any program analysis tools to prevent faults, and can then be used to judge static test suites, test generators, and execution frameworks. The test suite is supposed to only allow the original through, so any mutant that is not detected as faulty represents a bug in the test suite. Coverage is unable to determine the quality of assertion statements, which are an extremely important factor of test suite effectiveness, so injecting artificial faults allows us to better evaluate the quality of such assertions. Fault injection techniques analyze how the frequency of detection will provide us with the actual likelihood of the test suite to uncover bugs, provided we have a list of possible faults. However, since generating these faults is a manual process, they will be biased by the preconceptions of the developer. The majority of faults in a program is likely due to small variations in a program’s structure compared to the correct program. For a majority of larger faults composed of multiple smaller faults, a test suite detecting a single smaller fault is very likely to detect the larger fault that contains it. Generating a list of mutants, all possible valid variants of a program differing from the correct implementation by a smaller fault, is essential for generating test suites that apply to and kill each of these variants. For Python programs, we can convert the program into a tree (AST representation), then change small parts of the tree, which can then be passed through the Python interpreter for further processing. A simple way to produce a valid mutated version of a program is through replacing some of its statements with ‘pass’. While MuFunctionAnalyzer utilizes mutations of specific functions, MuProgramAnalyzer is the main class responsible for mutation analysis of the test suite, accepting the name of the module to be tested and its source code. The method ‘getitem’ accepts the test module, fixes the import entries on the test module to correctly point to the mutant module, and passes it to the test runner ‘MutantTestRunner’. The problem lies with equivalent mutants, mutants indistinguishable from the original in terms of semantics, whereas it becomes very difficult to judge the mutation score in their presence. A solution to this is inspecting mutants manually if they’re small enough, or randomly selecting a smaller amount of mutants to manually inspect if there’s a larger scale of them. Chao’s estimator can also be utilized to compute the result of the complete test matrix of each test against each mutant.</p>
</section>
<section id="reflection-7" class="level4">
<h4 class="anchored" data-anchor-id="reflection-7">Reflection</h4>
</section>
<section id="use-cases-7" class="level4">
<h4 class="anchored" data-anchor-id="use-cases-7">Use Cases</h4>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>