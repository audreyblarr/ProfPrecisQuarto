{"title":"ProfPrecisAudreyBlarr","markdown":{"yaml":{"title":"ProfPrecisAudreyBlarr"},"headingText":"Software Engineering at Google","containsRefs":false,"markdown":"\n\nMy name is Audrey Blarr, and welcome to my Quarto-generated website!\nHere, I will be posting my Professional Precis for CMPSC-203 Software Engineering.\n\nThis site features summaries, reflections, and use-cases regarding chapters of three books:\nFuzzingBook, DebuggingBook, and Software Engineering at Google\n\nTo learn more about Quarto websites visit <https://quarto.org/docs/websites>.\n\n\n## Preface\n\n#### Summary\n\nThe terms \"software engineering\" and \"programming\" have been used interchangeably over the years, although they have different implications. \nAs software engineering isn't currently as rigorous as other areas of engineering, more tedious methods of engineering will be necessary as \nsoftware becomes more commonly integrated into our lives. Software engineering can be referred to as \"programming integrated over time\", whereas \nwe focus on not only writing the code itself, but the tools and processes needed to achieve and maintain sustainable code. Within these\nprocesses, three main topics are of importance: \"time and change\", \"scale and growth\", and \"trade-offs and costs\".\n\n#### Reflection\n\n#### Use Cases\n\n## What is Software Engineering?\n\n#### Summary\n\nSoftware engineers must concern themselves with the need for change as time passes, unlike typical engineers. Furthermore, there exists issues\nof scale and efficiency, and outcomes with high stakes after making complex software decisions. Distinctions between \"software engineering\" and \n\"programming\" are very important, as the life span of given code allows for a prediction of its sustainability, or how much change will have to \nbe implemented to the program's dependencies. Capability is important when deciding whether or not to implement change. You also must consider\nthe scale of the project, especially since software engineering is typically a team effort. Although team projects can pose new problems, there's\nmore potential in discovering viable solutions. Trade-offs must be evaluated often, as some implementations come with higher stakes than others.\nThe level of broader change necessary to a program is dependent on both the amount of programmers working on a project, and their levels of skill \nin programming. Projects must also be adjusted to changing externalities, such as upgrades to programs, depending on the value and necessity of the\ngiven upgrade. Factors such as expertise, stability, conformity, familiarity, and policy can affect a codebase's flexibility. Some costs involved \nwithin trade-offs include financial, resource, personnel, transaction, opportunity, and societal costs. It's important to be evidence-driven rather\nthan making assumptions when debating trade-offs and the risks associated within.\n\n#### Reflection\n\n#### Use Cases\n\n## How to Work Well on Teams\n\n#### Summary\n\nCultural and social aspects of software engineering are crucial, as it's a team endeavor. A huge issue in the software engineering world includes \ninsecurity, as people are afraid of others viewing their unfinished work or criticizing their completed work. A phenomenon known as The Genius Myth \nis exhibited by many in the software engineering industry as we idolize individuals such as Linus Torvalds and attest them as the single-handed creators\nof large programs such as Linux. Although sparking the invention himself, Linus shared his implementations and discoveries with several others, allowing\nfor collaboration and new perspectives on debugging. The program is now a hundred times larger than its original kernal, and is being worked on by thousands. \nThe Genius Myth emerges because we strive to imitate these big-name creators rather than ulitizing the resources of collaboration in fear of being critcized \nfor not being a 'genius'. Hiding your code is super harmful, as you may not know if you're on the right track. It's easy to make fundamental mistakes early on,\nand collaborating allows you to increase the Bus Factor of your code. If you, the sole creator of a program, were to hypothetically get hit by a bus, there would\nbe nothing stopping your project from failing to be implemented. Working with others is also much faster, and it's much better to be a component of a successful \nprogram as opposed to the crucial part of a failed one. Working in a team allows for an instantaneous feedback loop so you know when to correct your plans or \ndesigns. The 'three pillars' of social skills and success include 'humility', 'respect', and 'trust', and creating relationships through these skills allow for richer \nrelationships with coworkers and an increased ability to complete the project. Properly documenting any failures within a project can prevent history from repeating \nitself and boost the understandings of others.\n\n#### Reflection\n\n#### Use Cases\n\n## Knowledge Sharing\n\n#### Summary\n\n#### Reflection\n\n#### Use Cases\n\n\n\n\n# FuzzingBook\n\n## Introduction to Software Testing\n\n#### Summary\n\nIt's essential to create testing for your implemented software to ensure accuracy. Simple examples of software testing \nmay include calculations like square-root testing, where you can incorporate Python control structures (while, if), assignments,\nand comparisons. You can incorporate 'print' statements into testing to observe closely how the function is being implemented. For \ninstances like the square root example, you can test its accuracy by working backwards and multiplying the answer to itself.\nHowever, it's more efficient to use automated testing, where you log the accurate answer and test the function to see if the \noutput matches the desired answer. The 'assert' keyword can be used, which returns nothing if the function's output matches and raises an error if not.\nYou can use an 'epsilon' value to ensure your function's output remains below a specified value, which gets rid of any rounding inaccuracies. These tests \ncan be incorporated straight into the implementation as well to save space and time. However, you must be able to both formulate and afford these run-time\nchecks. You can only test a finite amount of inputs, so there's a limit to the testing in that regard.\n\n#### Reflection\n\n#### Use Cases\n\n## Coverage\n\n#### Summary\n\nThe term \"code coverage\" refers to the ability to measure which parts of a program are being executed during a given test run, a process crucial for \nattempting to cover as much code as possible using a test generator. A simple Python command, 'cgi_decode()', will allow you to take an encoded string \nand decode it to its original form. You can derive tests using either Black-box testing, testing for specification, or White-box testing, testing for\nimplementation. White-box testing covers the structural features of a code, such as statement coverage and branch coverage. Furthermore, this method of \ntesting keeps track of which code was executed so a programmer can then focus on writing tests to cover the uncovered code. Dynamic analysis can take \nplace using the command 'sys.settrace()'to track how execution proceeds while decoding. Defining a 'Coverage' object to not only keep track of which \nlines are executed, but the function names as well, which is helpful when a program spans over many files. Along with Python, most other coding languages\nhave their own methods of testing code coverage. We must also set up a results checker to ensure that 'cgi_decode()' is error-free.\n\n#### Reflection\n\n#### Use Cases\n\n## Fuzzing\n\n#### Summary\n\nThe input of a program can take many forms, including data prompted by user or read from a file. These inputs determine how a program behaves, including its \nfailures, so it's important to test each valid input, or a program's 'language'. Grammars are used to specify input languages formally, where a wide range of \nthe properties of an input language is expressed, as well as the syntactical structure of an input. Consisting of a 'start' symbol followed by a set of \nexpansion rules, grammers formally define the language in the sense that anything that can be derived from 'start' using the expansion rules is part of the \nlanguage. Grammers can even be recursive and cover full arithmetic expressions. Using a format based on strings and lists is the simplest way to write grammars \nusing Python. However, this method may be inefficient with its large number of search and replace operations, and it may not even produce a string. Grammars are \nnot limited to just formal languages; they can be used to produce natural language as well. Grammar-generated inputs can be used as seeds in mutation-based \nfuzzing, where more complex constraints can be satisfied. Helper functions can be utilized in testing grammars, checking whether all used symbols are defined or \nnot, and whether or not they're reachable from the starting point.\n\n#### Reflection\n\n#### Use Cases\n\n## Mutation Analysis\n\n#### Summary\n\n#### Reflection\n\n#### Use Cases\n","srcMarkdownNoYaml":"\n\nMy name is Audrey Blarr, and welcome to my Quarto-generated website!\nHere, I will be posting my Professional Precis for CMPSC-203 Software Engineering.\n\nThis site features summaries, reflections, and use-cases regarding chapters of three books:\nFuzzingBook, DebuggingBook, and Software Engineering at Google\n\nTo learn more about Quarto websites visit <https://quarto.org/docs/websites>.\n\n# Software Engineering at Google\n\n## Preface\n\n#### Summary\n\nThe terms \"software engineering\" and \"programming\" have been used interchangeably over the years, although they have different implications. \nAs software engineering isn't currently as rigorous as other areas of engineering, more tedious methods of engineering will be necessary as \nsoftware becomes more commonly integrated into our lives. Software engineering can be referred to as \"programming integrated over time\", whereas \nwe focus on not only writing the code itself, but the tools and processes needed to achieve and maintain sustainable code. Within these\nprocesses, three main topics are of importance: \"time and change\", \"scale and growth\", and \"trade-offs and costs\".\n\n#### Reflection\n\n#### Use Cases\n\n## What is Software Engineering?\n\n#### Summary\n\nSoftware engineers must concern themselves with the need for change as time passes, unlike typical engineers. Furthermore, there exists issues\nof scale and efficiency, and outcomes with high stakes after making complex software decisions. Distinctions between \"software engineering\" and \n\"programming\" are very important, as the life span of given code allows for a prediction of its sustainability, or how much change will have to \nbe implemented to the program's dependencies. Capability is important when deciding whether or not to implement change. You also must consider\nthe scale of the project, especially since software engineering is typically a team effort. Although team projects can pose new problems, there's\nmore potential in discovering viable solutions. Trade-offs must be evaluated often, as some implementations come with higher stakes than others.\nThe level of broader change necessary to a program is dependent on both the amount of programmers working on a project, and their levels of skill \nin programming. Projects must also be adjusted to changing externalities, such as upgrades to programs, depending on the value and necessity of the\ngiven upgrade. Factors such as expertise, stability, conformity, familiarity, and policy can affect a codebase's flexibility. Some costs involved \nwithin trade-offs include financial, resource, personnel, transaction, opportunity, and societal costs. It's important to be evidence-driven rather\nthan making assumptions when debating trade-offs and the risks associated within.\n\n#### Reflection\n\n#### Use Cases\n\n## How to Work Well on Teams\n\n#### Summary\n\nCultural and social aspects of software engineering are crucial, as it's a team endeavor. A huge issue in the software engineering world includes \ninsecurity, as people are afraid of others viewing their unfinished work or criticizing their completed work. A phenomenon known as The Genius Myth \nis exhibited by many in the software engineering industry as we idolize individuals such as Linus Torvalds and attest them as the single-handed creators\nof large programs such as Linux. Although sparking the invention himself, Linus shared his implementations and discoveries with several others, allowing\nfor collaboration and new perspectives on debugging. The program is now a hundred times larger than its original kernal, and is being worked on by thousands. \nThe Genius Myth emerges because we strive to imitate these big-name creators rather than ulitizing the resources of collaboration in fear of being critcized \nfor not being a 'genius'. Hiding your code is super harmful, as you may not know if you're on the right track. It's easy to make fundamental mistakes early on,\nand collaborating allows you to increase the Bus Factor of your code. If you, the sole creator of a program, were to hypothetically get hit by a bus, there would\nbe nothing stopping your project from failing to be implemented. Working with others is also much faster, and it's much better to be a component of a successful \nprogram as opposed to the crucial part of a failed one. Working in a team allows for an instantaneous feedback loop so you know when to correct your plans or \ndesigns. The 'three pillars' of social skills and success include 'humility', 'respect', and 'trust', and creating relationships through these skills allow for richer \nrelationships with coworkers and an increased ability to complete the project. Properly documenting any failures within a project can prevent history from repeating \nitself and boost the understandings of others.\n\n#### Reflection\n\n#### Use Cases\n\n## Knowledge Sharing\n\n#### Summary\n\n#### Reflection\n\n#### Use Cases\n\n\n\n\n# FuzzingBook\n\n## Introduction to Software Testing\n\n#### Summary\n\nIt's essential to create testing for your implemented software to ensure accuracy. Simple examples of software testing \nmay include calculations like square-root testing, where you can incorporate Python control structures (while, if), assignments,\nand comparisons. You can incorporate 'print' statements into testing to observe closely how the function is being implemented. For \ninstances like the square root example, you can test its accuracy by working backwards and multiplying the answer to itself.\nHowever, it's more efficient to use automated testing, where you log the accurate answer and test the function to see if the \noutput matches the desired answer. The 'assert' keyword can be used, which returns nothing if the function's output matches and raises an error if not.\nYou can use an 'epsilon' value to ensure your function's output remains below a specified value, which gets rid of any rounding inaccuracies. These tests \ncan be incorporated straight into the implementation as well to save space and time. However, you must be able to both formulate and afford these run-time\nchecks. You can only test a finite amount of inputs, so there's a limit to the testing in that regard.\n\n#### Reflection\n\n#### Use Cases\n\n## Coverage\n\n#### Summary\n\nThe term \"code coverage\" refers to the ability to measure which parts of a program are being executed during a given test run, a process crucial for \nattempting to cover as much code as possible using a test generator. A simple Python command, 'cgi_decode()', will allow you to take an encoded string \nand decode it to its original form. You can derive tests using either Black-box testing, testing for specification, or White-box testing, testing for\nimplementation. White-box testing covers the structural features of a code, such as statement coverage and branch coverage. Furthermore, this method of \ntesting keeps track of which code was executed so a programmer can then focus on writing tests to cover the uncovered code. Dynamic analysis can take \nplace using the command 'sys.settrace()'to track how execution proceeds while decoding. Defining a 'Coverage' object to not only keep track of which \nlines are executed, but the function names as well, which is helpful when a program spans over many files. Along with Python, most other coding languages\nhave their own methods of testing code coverage. We must also set up a results checker to ensure that 'cgi_decode()' is error-free.\n\n#### Reflection\n\n#### Use Cases\n\n## Fuzzing\n\n#### Summary\n\nThe input of a program can take many forms, including data prompted by user or read from a file. These inputs determine how a program behaves, including its \nfailures, so it's important to test each valid input, or a program's 'language'. Grammars are used to specify input languages formally, where a wide range of \nthe properties of an input language is expressed, as well as the syntactical structure of an input. Consisting of a 'start' symbol followed by a set of \nexpansion rules, grammers formally define the language in the sense that anything that can be derived from 'start' using the expansion rules is part of the \nlanguage. Grammers can even be recursive and cover full arithmetic expressions. Using a format based on strings and lists is the simplest way to write grammars \nusing Python. However, this method may be inefficient with its large number of search and replace operations, and it may not even produce a string. Grammars are \nnot limited to just formal languages; they can be used to produce natural language as well. Grammar-generated inputs can be used as seeds in mutation-based \nfuzzing, where more complex constraints can be satisfied. Helper functions can be utilized in testing grammars, checking whether all used symbols are defined or \nnot, and whether or not they're reachable from the starting point.\n\n#### Reflection\n\n#### Use Cases\n\n## Mutation Analysis\n\n#### Summary\n\n#### Reflection\n\n#### Use Cases\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":"cosmo","title":"ProfPrecisAudreyBlarr"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}